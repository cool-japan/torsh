//! TensorBoard export functionality for sparse tensor profiling

use crate::TorshResult;
use std::collections::HashMap;
use std::fs::File;
use std::io::{BufWriter, Write};
use torsh_core::TorshError;

use super::super::core::PerformanceMeasurement;
use super::super::reporting::PerformanceReport;
use super::trend_analyzer::TrendAnalysis;

/// TensorBoard export functionality for sparse tensor profiling
///
/// Integrates with TensorBoard for visualization in ML workflows,
/// providing scalar logging, histogram visualization, and time-series tracking.
pub struct TensorBoardExporter {
    /// Step counter for TensorBoard logging
    step_counter: usize,
}

impl TensorBoardExporter {
    /// Create a new TensorBoard exporter
    pub fn new() -> Self {
        Self { step_counter: 0 }
    }

    /// Export performance measurements to TensorBoard scalar format
    ///
    /// Creates TensorBoard-compatible scalar logs for performance metrics
    /// including execution times, throughput, and memory usage.
    pub fn export_scalars(
        &mut self,
        measurements: &[PerformanceMeasurement],
        path: &str,
    ) -> TorshResult<()> {
        let file = File::create(path).map_err(|e| {
            TorshError::InvalidArgument(format!(
                "Failed to create TensorBoard log file {}: {}",
                path, e
            ))
        })?;

        let mut writer = BufWriter::new(file);

        // Write header comment
        writeln!(
            writer,
            "# TensorBoard scalars log generated by torsh-sparse"
        )
        .map_err(|e| TorshError::InvalidArgument(format!("Failed to write header: {}", e)))?;

        // Group measurements by operation for better organization
        let mut operations = HashMap::new();
        for measurement in measurements {
            operations
                .entry(&measurement.operation)
                .or_insert_with(Vec::new)
                .push(measurement);
        }

        // Export scalars for each operation
        for (operation, measurements) in operations {
            writeln!(writer, "\n# Operation: {}", operation).map_err(|e| {
                TorshError::InvalidArgument(format!("Failed to write operation header: {}", e))
            })?;

            for measurement in measurements {
                // Execution time
                writeln!(
                    writer,
                    "{}/execution_time_ms\t{}\t{:.3}",
                    operation,
                    self.step_counter,
                    measurement.duration.as_secs_f64() * 1000.0
                )
                .map_err(|e| {
                    TorshError::InvalidArgument(format!("Failed to write scalar: {}", e))
                })?;

                // Memory usage
                writeln!(
                    writer,
                    "{}/memory_usage_mb\t{}\t{:.3}",
                    operation,
                    self.step_counter,
                    measurement.memory_after as f64 / (1024.0 * 1024.0)
                )
                .map_err(|e| {
                    TorshError::InvalidArgument(format!("Failed to write scalar: {}", e))
                })?;

                // Memory delta
                writeln!(
                    writer,
                    "{}/memory_delta_mb\t{}\t{:.3}",
                    operation,
                    self.step_counter,
                    measurement.memory_delta() as f64 / (1024.0 * 1024.0)
                )
                .map_err(|e| {
                    TorshError::InvalidArgument(format!("Failed to write scalar: {}", e))
                })?;

                self.step_counter += 1;
            }
        }

        writer
            .flush()
            .map_err(|e| TorshError::InvalidArgument(format!("Failed to flush writer: {}", e)))?;

        Ok(())
    }

    /// Export performance report to TensorBoard format
    pub fn export_report(&mut self, report: &PerformanceReport, path: &str) -> TorshResult<()> {
        let file_path = format!("{}/performance_report.log", path);

        // Create directory if it doesn't exist
        if let Some(parent) = std::path::Path::new(&file_path).parent() {
            std::fs::create_dir_all(parent).map_err(|e| {
                TorshError::InvalidArgument(format!("Failed to create directory: {}", e))
            })?;
        }

        let file = File::create(&file_path).map_err(|e| {
            TorshError::InvalidArgument(format!(
                "Failed to create TensorBoard report file {}: {}",
                file_path, e
            ))
        })?;

        let mut writer = BufWriter::new(file);

        // Write report summary
        writeln!(
            writer,
            "# Performance Report - Generated at: {:?}",
            report.generated_at
        )
        .map_err(|e| TorshError::InvalidArgument(format!("Failed to write header: {}", e)))?;

        writeln!(
            writer,
            "# Total measurements: {}, Operations: {}",
            report.total_measurements, report.operation_count
        )
        .map_err(|e| TorshError::InvalidArgument(format!("Failed to write summary: {}", e)))?;

        // Export operation statistics
        for (operation, stats) in &report.operation_statistics {
            let step = self.step_counter;

            // Average execution time
            writeln!(
                writer,
                "{}/avg_time_ms\t{}\t{:.3}",
                operation,
                step,
                stats.avg_time().as_secs_f64() * 1000.0
            )
            .map_err(|e| TorshError::InvalidArgument(format!("Failed to write scalar: {}", e)))?;

            // Throughput
            writeln!(
                writer,
                "{}/throughput_ops_per_sec\t{}\t{:.2}",
                operation,
                step,
                stats.operations_per_second()
            )
            .map_err(|e| TorshError::InvalidArgument(format!("Failed to write scalar: {}", e)))?;

            // Memory efficiency
            writeln!(
                writer,
                "{}/memory_efficiency\t{}\t{:.3}",
                operation,
                step,
                stats.memory_efficiency()
            )
            .map_err(|e| TorshError::InvalidArgument(format!("Failed to write scalar: {}", e)))?;

            // Consistency score
            writeln!(
                writer,
                "{}/consistency_score\t{}\t{:.3}",
                operation,
                step,
                1.0 - stats.timing_consistency()
            )
            .map_err(|e| TorshError::InvalidArgument(format!("Failed to write scalar: {}", e)))?;

            self.step_counter += 1;
        }

        writer
            .flush()
            .map_err(|e| TorshError::InvalidArgument(format!("Failed to flush writer: {}", e)))?;

        Ok(())
    }

    /// Export trend analysis to TensorBoard
    pub fn export_trends(&mut self, trends: &[TrendAnalysis], path: &str) -> TorshResult<()> {
        let file_path = format!("{}/performance_trends.log", path);

        // Create directory if it doesn't exist
        if let Some(parent) = std::path::Path::new(&file_path).parent() {
            std::fs::create_dir_all(parent).map_err(|e| {
                TorshError::InvalidArgument(format!("Failed to create directory: {}", e))
            })?;
        }

        let file = File::create(&file_path).map_err(|e| {
            TorshError::InvalidArgument(format!(
                "Failed to create TensorBoard trends file {}: {}",
                file_path, e
            ))
        })?;

        let mut writer = BufWriter::new(file);

        writeln!(writer, "# Performance Trends Analysis")
            .map_err(|e| TorshError::InvalidArgument(format!("Failed to write header: {}", e)))?;

        for trend in trends {
            let step = self.step_counter;

            // Trend strength
            writeln!(
                writer,
                "{}/trend_strength\t{}\t{:.3}",
                trend.operation, step, trend.trend_strength
            )
            .map_err(|e| TorshError::InvalidArgument(format!("Failed to write scalar: {}", e)))?;

            // Performance change
            writeln!(
                writer,
                "{}/performance_change_percent\t{}\t{:.2}",
                trend.operation, step, trend.performance_change_percent
            )
            .map_err(|e| TorshError::InvalidArgument(format!("Failed to write scalar: {}", e)))?;

            // Confidence
            writeln!(
                writer,
                "{}/trend_confidence\t{}\t{:.3}",
                trend.operation, step, trend.confidence
            )
            .map_err(|e| TorshError::InvalidArgument(format!("Failed to write scalar: {}", e)))?;

            self.step_counter += 1;
        }

        writer
            .flush()
            .map_err(|e| TorshError::InvalidArgument(format!("Failed to flush writer: {}", e)))?;

        Ok(())
    }

    /// Export histogram data for performance distributions
    pub fn export_histograms(
        &mut self,
        measurements_by_operation: &HashMap<String, Vec<&PerformanceMeasurement>>,
        path: &str,
    ) -> TorshResult<()> {
        let file_path = format!("{}/performance_histograms.log", path);

        // Create directory if it doesn't exist
        if let Some(parent) = std::path::Path::new(&file_path).parent() {
            std::fs::create_dir_all(parent).map_err(|e| {
                TorshError::InvalidArgument(format!("Failed to create directory: {}", e))
            })?;
        }

        let file = File::create(&file_path).map_err(|e| {
            TorshError::InvalidArgument(format!(
                "Failed to create TensorBoard histogram file {}: {}",
                file_path, e
            ))
        })?;

        let mut writer = BufWriter::new(file);

        writeln!(writer, "# Performance Distribution Histograms")
            .map_err(|e| TorshError::InvalidArgument(format!("Failed to write header: {}", e)))?;

        for (operation, measurements) in measurements_by_operation {
            if measurements.is_empty() {
                continue;
            }

            writeln!(writer, "\n# Operation: {}", operation).map_err(|e| {
                TorshError::InvalidArgument(format!("Failed to write operation header: {}", e))
            })?;

            // Extract timing data
            let mut times: Vec<f64> = measurements
                .iter()
                .map(|m| m.duration.as_secs_f64() * 1000.0)
                .collect();
            times.sort_by(|a, b| a.partial_cmp(b).unwrap());

            // Simple histogram representation
            let min_time = times[0];
            let max_time = times[times.len() - 1];
            let bucket_count = 10;
            let bucket_size = (max_time - min_time) / bucket_count as f64;

            for i in 0..bucket_count {
                let bucket_start = min_time + i as f64 * bucket_size;
                let bucket_end = bucket_start + bucket_size;
                let count = times
                    .iter()
                    .filter(|&&time| time >= bucket_start && time < bucket_end)
                    .count();

                writeln!(
                    writer,
                    "{}/histogram_bucket_{}\t{}\t{}",
                    operation, i, self.step_counter, count
                )
                .map_err(|e| {
                    TorshError::InvalidArgument(format!("Failed to write histogram data: {}", e))
                })?;
            }

            self.step_counter += 1;
        }

        writer
            .flush()
            .map_err(|e| TorshError::InvalidArgument(format!("Failed to flush writer: {}", e)))?;

        Ok(())
    }

    /// Get current step counter
    pub fn step_counter(&self) -> usize {
        self.step_counter
    }

    /// Reset step counter
    pub fn reset_step_counter(&mut self) {
        self.step_counter = 0;
    }
}

impl Default for TensorBoardExporter {
    fn default() -> Self {
        Self::new()
    }
}
